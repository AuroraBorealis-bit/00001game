<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>金角银边-井字棋游戏 v4.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">

    <!-- 自定义Tailwind配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5', // 主色调：紫色
                        secondary: '#10B981', // 辅助色：绿色
                        accent: '#F59E0B', // 强调色：橙色
                        dark: '#1F2937',
                        light: '#F9FAFB'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    animation: {
                        'bounce-subtle': 'bounce-subtle 1.5s infinite',
                    },
                    keyframes: {
                        'bounce-subtle': {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-5px)' },
                        }
                    }
                },
            }
        }
    </script>

    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .board-cell {
                @apply relative aspect-square border-2 border-gray-300 cursor-pointer transition-all duration-200 hover:bg-gray-100;
            }
            .board-cell-x::after {
                @apply absolute inset-0 flex items-center justify-center text-4xl font-bold text-primary content-['X'];
            }
            .board-cell-o::after {
                @apply absolute inset-0 flex items-center justify-center text-4xl font-bold text-secondary content-['O'];
            }
            .btn-primary {
                @apply bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-primary/50;
            }
            .btn-secondary {
                @apply bg-secondary hover:bg-secondary/90 text-white font-medium py-2 px-4 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-secondary/50;
            }
            .select-custom {
                @apply bg-white border border-gray-300 text-gray-700 py-2 px-4 pr-8 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary appearance-none cursor-pointer;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-light to-gray-100 min-h-screen flex flex-col items-center justify-center p-4">
    <!-- 顶部标题 -->
    <header class="mb-8 text-center">
        <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-dark mb-2">
            <span class="text-primary">金角银边</span> - 井字棋游戏
        </h1>
        <p class="text-gray-500 text-lg">策略性4x4井字棋挑战</p>
    </header>

    <!-- 游戏容器 -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 w-full max-w-5xl">
        <!-- 玩家对战程序 -->
        <div class="bg-white rounded-xl shadow-lg overflow-hidden transform transition-all duration-300 hover:shadow-xl">
            <div class="bg-primary text-white p-4">
                <h2 class="text-xl font-bold flex items-center">
                    <i class="fa-solid fa-robot mr-2"></i> 玩家 vs 程序
                </h2>
            </div>
            <div class="p-6">
                <div class="flex flex-wrap gap-4 mb-6">
                    <div>
                        <label class="block text-gray-700 mb-2">难度:</label>
                        <select id="difficulty-select" class="select-custom">
                            <option value="easy">简单</option>
                            <option value="hard">困难</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-gray-700 mb-2">先手:</label>
                        <select id="first-hand-select" class="select-custom">
                            <option value="player">玩家先手</option>
                            <option value="ai">AI先手</option>
                        </select>
                    </div>
                </div>

                <div class="mb-4">
                    <p id="playerLabelPVE" class="text-lg font-medium text-gray-800">
                        当前玩家: <span class="inline-block w-6 h-6 rounded-full bg-primary/20 text-primary flex items-center justify-center">X</span>
                    </p>
                </div>

                <!-- 棋盘 -->
                <div class="relative mx-auto w-full max-w-xs aspect-square bg-gray-50 rounded-lg shadow-inner overflow-hidden">
                    <table id="boardPVE" class="w-full h-full">
                        <!-- JavaScript 将动态生成棋盘 -->
                    </table>
                </div>

                <div class="mt-6">
                    <p class="text-sm text-gray-600 italic">
                        <i class="fa-solid fa-info-circle mr-1"></i> 规则：在行、列或对角线上连成三个的玩家将赢得游戏。注意：在第 12 步之前不要输入中心区域！
                    </p>
                </div>

                <div class="mt-6 text-center">
                    <button id="restartPVE" class="btn-primary">
                        <i class="fa-solid fa-refresh mr-2"></i> 重新开始
                    </button>
                </div>
            </div>
        </div>

        <!-- 玩家对战玩家 -->
        <div class="bg-white rounded-xl shadow-lg overflow-hidden transform transition-all duration-300 hover:shadow-xl">
            <div class="bg-secondary text-white p-4">
                <h2 class="text-xl font-bold flex items-center">
                    <i class="fa-solid fa-users mr-2"></i> 玩家对战
                </h2>
            </div>
            <div class="p-6">
                <div class="mb-4">
                    <p id="playerLabelPVP" class="text-lg font-medium text-gray-800">
                        当前玩家: <span class="inline-block w-6 h-6 rounded-full bg-primary/20 text-primary flex items-center justify-center">X</span>
                    </p>
                </div>

                <!-- 棋盘 -->
                <div class="relative mx-auto w-full max-w-xs aspect-square bg-gray-50 rounded-lg shadow-inner overflow-hidden">
                    <table id="boardPVP" class="w-full h-full">
                        <!-- JavaScript 将动态生成棋盘 -->
                    </table>
                </div>

                <div class="mt-6">
                    <p class="text-sm text-gray-600 italic">
                        <i class="fa-solid fa-info-circle mr-1"></i> 规则：在行、列或对角线上连成三个的玩家将赢得游戏。注意：在第 12 步之前不要输入中心区域！
                    </p>
                </div>

                <div class="mt-6 text-center">
                    <button id="restartPVP" class="btn-secondary">
                        <i class="fa-solid fa-refresh mr-2"></i> 重新开始
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- 页脚 -->
    <footer class="mt-10 text-center text-gray-500 text-sm">
        <p>版本号: 4.0 </p>
        <p class="mt-2">© 2025 made by zzo | <i class="fa-solid fa-shield-check"></i> 安全游戏体验</p>
    </footer>

    <script>
        // 玩家对战程序游戏部分
        const sPVE = 4;
        let boardPVE = Array.from({ length: sPVE }, () => Array(sPVE).fill(-1));
        let resultPVE = -1;
        let stepPVE = 1;
        let gameCountPVE = 0; // 记录玩家对战程序游戏的次数
        const boardElementPVE = document.getElementById('boardPVE');
        const difficultySelect = document.getElementById('difficulty-select');
        const restartButtonPVE = document.getElementById('restartPVE');
        const firstHandSelect = document.getElementById('first-hand-select');

        // 创建棋盘
        for (let i = 0; i < sPVE; i++) {
            const row = document.createElement('tr');
            for (let j = 0; j < sPVE; j++) {
                const cell = document.createElement('td');
                cell.className = 'board-cell';
                cell.dataset.row = i;
                cell.dataset.col = j;
                cell.addEventListener('click', () => handlePlayerClickPVE(i, j));
                row.appendChild(cell);
            }
            boardElementPVE.appendChild(row);
        }

        // 检查是否有玩家获胜的函数
        function checkWinnerPVE() {
            // 检查行
            for (let i = 0; i < sPVE; i++) {
                let numberX = 0;
                let numberO = 0;
                if (boardPVE[i][1]!== boardPVE[i][2]) continue;
                for (let j = 0; j < sPVE; j++) {
                    if (boardPVE[i][j] === 1) numberX++;
                    else if (boardPVE[i][j] === 0) numberO++;
                    else continue;
                    if (numberX === 3 || numberO === 3) {
                        resultPVE = numberX === 3? 1 : 0;
                        return;
                    }
                }
            }

            // 检查列
            for (let j = 0; j < sPVE; j++) {
                let numberX = 0;
                let numberO = 0;
                if (boardPVE[1][j]!== boardPVE[2][j]) continue;
                for (let i = 0; i < sPVE; i++) {
                    if (boardPVE[i][j] === 1) numberX++;
                    else if (boardPVE[i][j] === 0) numberO++;
                    else continue;
                    if (numberX === 3 || numberO === 3) {
                        resultPVE = numberX === 3? 1 : 0;
                        return;
                    }
                }
            }

            // 检查对角线
            function checkAndSetPVE(r1, c1, r2, c2, r3, c3) {
                if (resultPVE === -1 && boardPVE[r1][c1] === boardPVE[r2][c2] && boardPVE[r2][c2] === boardPVE[r3][c3]) {
                    resultPVE = boardPVE[r2][c2];
                }
            }

            checkAndSetPVE(0, 0, 1, 1, 2, 2);
            checkAndSetPVE(1, 1, 2, 2, 3, 3);
            checkAndSetPVE(0, 3, 1, 2, 2, 1);
            checkAndSetPVE(3, 0, 2, 1, 1, 2);
            checkAndSetPVE(0, 1, 1, 2, 2, 3);
            checkAndSetPVE(1, 0, 2, 1, 3, 2);
            checkAndSetPVE(0, 2, 1, 1, 2, 0);
            checkAndSetPVE(1, 3, 2, 2, 3, 1);
        }

        // 处理玩家点击事件
        function handlePlayerClickPVE(row, col) {
            if (resultPVE!== -1) {
                showNotification("游戏已结束，请重新开始。", "error");
                return;
            }
            if (boardPVE[row][col]!== -1) {
                showNotification("该位置已被占用，请选择其他位置。", "error");
                return;
            }
            if (1 <= row && row < 3 && 1 <= col && col < 3 && stepPVE < 12) {
                showNotification("请在第 12 步之前选择边缘位置。", "warning");
                return;
            }

            // 更新棋盘状态
            boardPVE[row][col] = 1;
            const cell = boardElementPVE.rows[row].cells[col];
            cell.classList.add('board-cell-x');
            cell.classList.add('animate-bounce-subtle');
            setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

            stepPVE++;
            updatePlayerLabelPVE();

            if (stepPVE > 4) {
                checkWinnerPVE();
                if (resultPVE === 1) {
                    showEndMessagePVE("恭喜！你赢得了游戏！");
                } else if (stepPVE < sPVE * sPVE) {
                    setTimeout(handleAIInputPVE, 500);
                } else if (stepPVE === sPVE * sPVE) {
                    showEndMessagePVE("平局，没有人获胜。");
                }
            } else {
                setTimeout(handleAIInputPVE, 500);
            }
        }

        // 更新玩家标签显示
        function updatePlayerLabelPVE() {
            const label = document.getElementById('playerLabelPVE');
            const currentPlayer = stepPVE % 2 === 1? 'X' : 'O';
            const colorClass = currentPlayer === 'X'? 'bg-primary/20 text-primary' : 'bg-secondary/20 text-secondary';
            label.innerHTML = `当前玩家: <span class="inline-block w-6 h-6 rounded-full ${colorClass} flex items-center justify-center">${currentPlayer}</span>`;
        }

        // 优化后的 AI 算法
        function handleAIInputPVE() {
            const difficulty = difficultySelect.value;
            let winRow = -1, winCol = -1;
            let blockRow = -1, blockCol = -1;
            let specialRow = -1, specialCol = -1;
            let availableMoves = [];
            let preferredMoves = [];

            // 检查是否有能让 AI 获胜的位置
            for (let i = 0; i < sPVE; i++) {
                for (let j = 0; j < sPVE; j++) {
                    if (boardPVE[i][j] === -1) {
                        if (1 <= i && i < 3 && 1 <= j && j < 3 && stepPVE < 12) continue;
                        boardPVE[i][j] = 0;
                        checkWinnerPVE();
                        if (resultPVE === 0) {
                            winRow = i;
                            winCol = j;
                        }
                        resultPVE = -1;
                        boardPVE[i][j] = -1;
                    }
                }
            }

            if (winRow!== -1) {
                boardPVE[winRow][winCol] = 0;
                const cell = boardElementPVE.rows[winRow].cells[winCol];
                cell.classList.add('board-cell-o');
                cell.classList.add('animate-bounce-subtle');
                setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

                stepPVE++;
                updatePlayerLabelPVE();

                checkWinnerPVE();
                if (resultPVE === 0) {
                    showEndMessagePVE("很遗憾，你输了。");
                }
                return;
            }

            // 检查是否有需要阻止玩家获胜的位置
            for (let i = 0; i < sPVE; i++) {
                for (let j = 0; j < sPVE; j++) {
                    if (boardPVE[i][j] === -1) {
                        if (1 <= i && i < 3 && 1 <= j && j < 3 && stepPVE < 12) continue;
                        boardPVE[i][j] = 1;
                        checkWinnerPVE();
                        if (resultPVE === 1) {
                            blockRow = i;
                            blockCol = j;
                        }
                        resultPVE = -1;
                        boardPVE[i][j] = -1;
                    }
                }
            }

            if (blockRow!== -1) {
                boardPVE[blockRow][blockCol] = 0;
                const cell = boardElementPVE.rows[blockRow].cells[blockCol];
                cell.classList.add('board-cell-o');
                cell.classList.add('animate-bounce-subtle');
                setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

                stepPVE++;
                updatePlayerLabelPVE();

                if (stepPVE > 4) {
                    checkWinnerPVE();
                    if (resultPVE === 0) {
                        showEndMessagePVE("很遗憾，你输了。");
                    } else if (stepPVE === sPVE * sPVE) {
                        showEndMessagePVE("平局，没有人获胜。");
                    }
                }
                return;
            }

            if (difficulty === 'hard' && stepPVE < 12 && firstHandSelect.value === 'ai') {
                // 检查边缘两行或两列中间两格已存在一个AI的落子时，优先选择该行或该列的另一个中间位置落子
                for (let i = 0; i < sPVE; i++) {
                    if (i === 0 || i === 3) {
                        if (boardPVE[i][1] === 0 && boardPVE[i][2] === -1) {
                            specialRow = i;
                            specialCol = 2;
                            break;
                        } else if (boardPVE[i][2] === 0 && boardPVE[i][1] === -1) {
                            specialRow = i;
                            specialCol = 1;
                            break;
                        }
                    }
                }
                if (specialRow === -1) {
                    for (let j = 0; j < sPVE; j++) {
                        if (j === 0 || j === 3) {
                            if (boardPVE[1][j] === 0 && boardPVE[2][j] === -1) {
                                specialRow = 2;
                                specialCol = j;
                                break;
                            } else if (boardPVE[2][j] === 0 && boardPVE[1][j] === -1) {
                                specialRow = 1;
                                specialCol = j;
                                break;
                            }
                        }
                    }
                }
            }

            if (specialRow!== -1) {
                boardPVE[specialRow][specialCol] = 0;
                const cell = boardElementPVE.rows[specialRow].cells[specialCol];
                cell.classList.add('board-cell-o');
                cell.classList.add('animate-bounce-subtle');
                setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

                stepPVE++;
                updatePlayerLabelPVE();

                if (stepPVE > 4) {
                    checkWinnerPVE();
                    if (resultPVE === 0) {
                        showEndMessagePVE("很遗憾，你输了。");
                    } else if (stepPVE === sPVE * sPVE) {
                        showEndMessagePVE("平局，没有人获胜。");
                    }
                }
                return;
            }

            if (difficulty === 'hard') {
                if (stepPVE === 1 && firstHandSelect.value === 'ai') {
                    // 困难模式下 AI 先手的优化落子策略，优先选择每行或每列的中间部分且不在中间四格
                    const validPositions = [];
                    for (let i = 0; i < sPVE; i++) {
                        for (let j = 0; j < sPVE; j++) {
                            if (boardPVE[i][j] === -1 &&!(1 <= i && i < 3 && 1 <= j && j < 3)) {
                                if ((i === 0 || i === 3) && (j === 1 || j === 2)) {
                                    validPositions.push([i, j]);
                                }
                            }
                        }
                    }
                    if (validPositions.length > 0) {
                        const randomIndex = Math.floor(Math.random() * validPositions.length);
                        const [row, col] = validPositions[randomIndex];
                        boardPVE[row][col] = 0;
                        const cell = boardElementPVE.rows[row].cells[col];
                        cell.classList.add('board-cell-o');
                        cell.classList.add('animate-bounce-subtle');
                        setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

                        stepPVE++;
                        updatePlayerLabelPVE();
                        return;
                    }
                }

                // 困难难度的特殊情况检测
                if (stepPVE <= 10) {
                    // 检查行
                    for (let i = 0; i < sPVE; i++) {
                        let hasXInMiddle = (boardPVE[i][1] === 1 || boardPVE[i][2] === 1);
                        let allOthersEmpty = true;
                        let hasBothXO = false;
                        let hasX = false;
                        let hasO = false;
                        for (let j = 0; j < sPVE; j++) {
                            if (j!== 1 && j!== 2 && boardPVE[i][j]!== -1) {
                                allOthersEmpty = false;
                            }
                            if (boardPVE[i][j] === 1) {
                                hasX = true;
                            }
                            if (boardPVE[i][j] === 0) {
                                hasO = true;
                            }
                            if (hasX && hasO) {
                                hasBothXO = true;
                                break;
                            }
                        }
                        if (hasBothXO) {
                            continue;
                        }
                        if (hasXInMiddle && allOthersEmpty) {
                            // 优先尝试中间的空格
                            if (boardPVE[i][1] === -1 &&!(1 <= i && i < 3 && 1 <= 1 && 1 < 3 && stepPVE < 12)) {
                                specialRow = i;
                                specialCol = 1;
                            } else if (boardPVE[i][2] === -1 &&!(1 <= i && i < 3 && 1 <= 2 && 2 < 3 && stepPVE < 12)) {
                                specialRow = i;
                                specialCol = 2;
                            }
                            if (specialRow === -1) {
                                // 若中间空格不符合条件，遍历其他空格
                                for (let j = 0; j < sPVE; j++) {
                                    if (boardPVE[i][j] === -1) {
                                        if (1 <= i && i < 3 && 1 <= j && j < 3 && stepPVE < 12) continue;
                                        specialRow = i;
                                        specialCol = j;
                                        break;
                                    }
                                }
                            }
                            if (specialRow!== -1) break;
                        }
                    }

                    // 若行中未找到，检查列
                    if (specialRow === -1) {
                        for (let j = 0; j < sPVE; j++) {
                            let hasXInMiddle = (boardPVE[1][j] === 1 || boardPVE[2][j] === 1);
                            let allOthersEmpty = true;
                            let hasBothXO = false;
                            let hasX = false;
                            let hasO = false;
                            for (let i = 0; i < sPVE; i++) {
                                if (i!== 1 && i!== 2 && boardPVE[i][j]!== -1) {
                                    allOthersEmpty = false;
                                }
                                if (boardPVE[i][j] === 1) {
                                    hasX = true;
                                }
                                if (boardPVE[i][j] === 0) {
                                    hasO = true;
                                }
                                if (hasX && hasO) {
                                    hasBothXO = true;
                                    break;
                                }
                            }
                            if (hasBothXO) {
                                continue;
                            }
                            if (hasXInMiddle && allOthersEmpty) {
                                // 优先尝试中间的空格
                                if (boardPVE[1][j] === -1 &&!(1 <= 1 && 1 < 3 && 1 <= j && j < 3 && stepPVE < 12)) {
                                    specialRow = 1;
                                    specialCol = j;
                                } else if (boardPVE[2][j] === -1 &&!(1 <= 2 && 2 < 3 && 1 <= j && j < 3 && stepPVE < 12)) {
                                    specialRow = 2;
                                    specialCol = j;
                                }
                                if (specialRow === -1) {
                                    // 若中间空格不符合条件，遍历其他空格
                                    for (let i = 0; i < sPVE; i++) {
                                        if (boardPVE[i][j] === -1) {
                                            if (1 <= i && i < 3 && 1 <= j && j < 3 && stepPVE < 12) continue;
                                            specialRow = i;
                                            specialCol = j;
                                            break;
                                        }
                                    }
                                }
                                if (specialRow!== -1) break;
                            }
                        }
                    }
                }
            } else {
                // 简单难度的特殊情况检测
                if (stepPVE <= 6) {
                    // 检查行
                    for (let i = 0; i < sPVE; i++) {
                        let hasXInMiddle = (boardPVE[i][1] === 1 || boardPVE[i][2] === 1);
                        let allOthersEmpty = true;
                        for (let j = 0; j < sPVE; j++) {
                            if (j!== 1 && j!== 2 && boardPVE[i][j]!== -1) {
                                allOthersEmpty = false;
                                break;
                            }
                        }
                        if (hasXInMiddle && allOthersEmpty) {
                            for (let j = 0; j < sPVE; j++) {
                                if (boardPVE[i][j] === -1) {
                                    if (1 <= i && i < 3 && 1 <= j && j < 3 && stepPVE < 12) continue;
                                    specialRow = i;
                                    specialCol = j;
                                    break;
                                }
                            }
                            if (specialRow!== -1) break;
                        }
                    }

                    // 若行中未找到，检查列
                    if (specialRow === -1) {
                        for (let j = 0; j < sPVE; j++) {
                            let hasXInMiddle = (boardPVE[1][j] === 1 || boardPVE[2][j] === 1);
                            let allOthersEmpty = true;
                            for (let i = 0; i < sPVE; i++) {
                                if (i!== 1 && i!== 2 && boardPVE[i][j]!== -1) {
                                    allOthersEmpty = false;
                                    break;
                                }
                            }
                            if (hasXInMiddle && allOthersEmpty) {
                                for (let i = 0; i < sPVE; i++) {
                                    if (boardPVE[i][j] === -1) {
                                        if (1 <= i && i < 3 && 1 <= j && j < 3 && stepPVE < 12) continue;
                                        specialRow = i;
                                        specialCol = j;
                                        break;
                                    }
                                }
                                if (specialRow!== -1) break;
                            }
                        }
                    }
                }
            }

            if (specialRow!== -1) {
                boardPVE[specialRow][specialCol] = 0;
                const cell = boardElementPVE.rows[specialRow].cells[specialCol];
                cell.classList.add('board-cell-o');
                cell.classList.add('animate-bounce-subtle');
                setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

                stepPVE++;
                updatePlayerLabelPVE();

                if (stepPVE > 4) {
                    checkWinnerPVE();
                    if (resultPVE === 0) {
                        showEndMessagePVE("很遗憾，你输了。");
                    } else if (stepPVE === sPVE * sPVE) {
                        showEndMessagePVE("平局，没有人获胜。");
                    }
                }
                return;
            }

            // 收集所有可用的位置
            for (let i = 0; i < sPVE; i++) {
                for (let j = 0; j < sPVE; j++) {
                    if (boardPVE[i][j] === -1) {
                        if (1 <= i && i < 3 && 1 <= j && j < 3 && stepPVE < 12) continue;
                        availableMoves.push([i, j]);
                        if ((i === 0 || i === 3) && (j === 1 || j === 2)) {
                            preferredMoves.push([i, j]);
                        }
                    }
                }
            }

            if (preferredMoves.length > 0) {
                let randomIndex = Math.floor(Math.random() * preferredMoves.length);
                let [row, col] = preferredMoves[randomIndex];
                boardPVE[row][col] = 0;
                const cell = boardElementPVE.rows[row].cells[col];
                cell.classList.add('board-cell-o');
                cell.classList.add('animate-bounce-subtle');
                setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

                stepPVE++;
                updatePlayerLabelPVE();

                if (stepPVE > 4) {
                    checkWinnerPVE();
                    if (resultPVE === 0) {
                        showEndMessagePVE("很遗憾，你输了。");
                    } else if (stepPVE === sPVE * sPVE) {
                        showEndMessagePVE("平局，没有人获胜。");
                    }
                }
            } else if (availableMoves.length > 0) {
                let randomIndex = Math.floor(Math.random() * availableMoves.length);
                let [row, col] = availableMoves[randomIndex];
                boardPVE[row][col] = 0;
                const cell = boardElementPVE.rows[row].cells[col];
                cell.classList.add('board-cell-o');
                cell.classList.add('animate-bounce-subtle');
                setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

                stepPVE++;
                updatePlayerLabelPVE();

                if (stepPVE > 4) {
                    checkWinnerPVE();
                    if (resultPVE === 0) {
                        showEndMessagePVE("很遗憾，你输了。");
                    } else if (stepPVE === sPVE * sPVE) {
                        showEndMessagePVE("平局，没有人获胜。");
                    }
                }
            }
        }

        // 显示游戏结束信息，并提供再来一局的选项
        function showEndMessagePVE(message) {
            gameCountPVE++;
            const notification = document.createElement('div');
            notification.className = 'fixed inset-0 flex items-center justify-center bg-black/50 z-50 transition-opacity duration-300';
            notification.innerHTML = `
                <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full transform transition-all duration-300 scale-100">
                    <div class="text-center">
                        <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-primary/10 text-primary mb-4">
                            <i class="fa-solid fa-trophy text-2xl"></i>
                        </div>
                        <h3 class="text-xl font-bold text-gray-900 mb-2">${message}</h3>
                        <p class="text-gray-600 mb-6">本局共进行了 ${stepPVE-1} 步</p>
                        <div class="flex justify-center">
                            <button id="playAgainPVE" class="btn-primary">
                                <i class="fa-solid fa-play mr-2"></i> 再来一局
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(notification);

            document.getElementById('playAgainPVE').addEventListener('click', () => {
                notification.classList.add('opacity-0');
                setTimeout(() => {
                    document.body.removeChild(notification);
                    restartGamePVE();
                }, 300);
            });
        }

        // 显示通知消息
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            const bgColor = type === 'error' ? 'bg-red-500' : type === 'warning' ? 'bg-yellow-500' : 'bg-blue-500';
            const icon = type === 'error' ? 'fa-exclamation-circle' : type === 'warning' ? 'fa-exclamation-triangle' : 'fa-info-circle';

            notification.className = `fixed top-4 right-4 ${bgColor} text-white px-4 py-3 rounded-lg shadow-lg transform transition-all duration-300 translate-x-full z-50 flex items-center`;
            notification.innerHTML = `
                <i class="fa-solid ${icon} mr-2"></i>
                <span>${message}</span>
            `;
            document.body.appendChild(notification);

            // 显示通知
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 100);

            // 自动关闭
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // 重新开始玩家对战程序游戏
        function restartGamePVE() {
            resultPVE = -1;
            stepPVE = 1;
            boardPVE = Array.from({ length: sPVE }, () => Array(sPVE).fill(-1));

            // 清除棋盘
            for (let i = 0; i < sPVE; i++) {
                for (let j = 0; j < sPVE; j++) {
                    const cell = boardElementPVE.rows[i].cells[j];
                    cell.className = 'board-cell';
                }
            }

            const firstHand = firstHandSelect.value;
            updatePlayerLabelPVE();

            if (firstHand === 'ai') {
                setTimeout(handleAIInputPVE, 500);
            }
        }

        // 为重新开始按钮绑定事件
        restartButtonPVE.addEventListener('click', restartGamePVE);

        // 玩家对战游戏部分
        const sPVP = 4;
        let boardPVP = Array.from({ length: sPVP }, () => Array(sPVP).fill(-1));
        let resultPVP = -1;
        let currentPlayerPVP = -1;
        let stepPVP = 1;
        let gameCountPVP = 0; // 记录玩家对战游戏的次数
        const boardElementPVP = document.getElementById('boardPVP');
        const restartButtonPVP = document.getElementById('restartPVP');

        // 创建棋盘
        for (let i = 0; i < sPVP; i++) {
            const row = document.createElement('tr');
            for (let j = 0; j < sPVP; j++) {
                const cell = document.createElement('td');
                cell.className = 'board-cell';
                cell.dataset.row = i;
                cell.dataset.col = j;
                cell.addEventListener('click', () => onClickPVP(i, j));
                row.appendChild(cell);
            }
            boardElementPVP.appendChild(row);
        }

        // 检查是否有玩家获胜的函数
        function checkWinnerPVP() {
            // 检查行
            for (let i = 0; i < sPVP; i++) {
                let numberX = 0;
                let numberO = 0;
                if (boardPVP[i][1]!== boardPVP[i][2]) continue;
                for (let j = 0; j < sPVP; j++) {
                    if (boardPVP[i][j] === 1) numberX++;
                    else if (boardPVP[i][j] === 0) numberO++;
                    else continue;
                    if (numberX === 3 || numberO === 3) {
                        resultPVP = numberX === 3? 1 : 0;
                        return;
                    }
                }
            }

            // 检查列
            for (let j = 0; j < sPVP; j++) {
                let numberX = 0;
                let numberO = 0;
                if (boardPVP[1][j]!== boardPVP[2][j]) continue;
                for (let i = 0; i < sPVP; i++) {
                    if (boardPVP[i][j] === 1) numberX++;
                    else if (boardPVP[i][j] === 0) numberO++;
                    else continue;
                    if (numberX === 3 || numberO === 3) {
                        resultPVP = numberX === 3? 1 : 0;
                        return;
                    }
                }
            }

            // 检查对角线
            function checkAndSetPVP(r1, c1, r2, c2, r3, c3) {
                if (resultPVP === -1 && boardPVP[r1][c1] === boardPVP[r2][c2] && boardPVP[r2][c2] === boardPVP[r3][c3]) {
                    resultPVP = boardPVP[r2][c2];
                }
            }

            checkAndSetPVP(0, 0, 1, 1, 2, 2);
            checkAndSetPVP(1, 1, 2, 2, 3, 3);
            checkAndSetPVP(0, 3, 1, 2, 2, 1);
            checkAndSetPVP(3, 0, 2, 1, 1, 2);
            checkAndSetPVP(0, 1, 1, 2, 2, 3);
            checkAndSetPVP(1, 0, 2, 1, 3, 2);
            checkAndSetPVP(0, 2, 1, 1, 2, 0);
            checkAndSetPVP(1, 3, 2, 2, 3, 1);
        }

        // 更新玩家标签显示
        function updatePlayerLabelPVP() {
            const label = document.getElementById('playerLabelPVP');
            const currentPlayer = currentPlayerPVP === -1? 'X' : 'O';
            const colorClass = currentPlayer === 'X'? 'bg-primary/20 text-primary' : 'bg-secondary/20 text-secondary';
            label.innerHTML = `当前玩家: <span class="inline-block w-6 h-6 rounded-full ${colorClass} flex items-center justify-center">${currentPlayer}</span>`;
        }

        // 处理按钮点击事件的函数
        function onClickPVP(row, col) {
            if (resultPVP!== -1) {
                showNotification("游戏已结束，请重新开始。", "error");
                return;
            }
            if (boardPVP[row][col]!== -1) {
                showNotification("该位置已被占用，请选择其他位置。", "error");
                return;
            }
            if (1 <= row && row < 3 && 1 <= col && col < 3 && stepPVP < 12) {
                showNotification("请在第 12 步之前选择边缘位置。", "warning");
                return;
            }

            // 更新棋盘状态
            const player = currentPlayerPVP === -1? 1 : 0;
            boardPVP[row][col] = player;
            const cell = boardElementPVP.rows[row].cells[col];
            cell.classList.add(player === 1? 'board-cell-x' : 'board-cell-o');
            cell.classList.add('animate-bounce-subtle');
            setTimeout(() => cell.classList.remove('animate-bounce-subtle'), 1000);

            stepPVP++;
            currentPlayerPVP *= -1;
            updatePlayerLabelPVP();

            if (stepPVP === 11) {
                showNotification("注意：O 现在可以输入中心位置。", "info");
            }

            if (stepPVP > 4) {
                checkWinnerPVP();
                if (resultPVP === 1) {
                    showEndMessagePVP("恭喜！玩家 X 赢得了游戏！");
                } else if (resultPVP === 0) {
                    showEndMessagePVP("恭喜！玩家 O 赢得了游戏！");
                } else if (stepPVP === sPVP * sPVP) {
                    showEndMessagePVP("平局，没有人获胜。");
                }
            }
        }

        // 显示游戏结束信息，并提供再来一局的选项
        function showEndMessagePVP(message) {
            gameCountPVP++;
            const notification = document.createElement('div');
            notification.className = 'fixed inset-0 flex items-center justify-center bg-black/50 z-50 transition-opacity duration-300';
            notification.innerHTML = `
                <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full transform transition-all duration-300 scale-100">
                    <div class="text-center">
                        <div class="inline-flex items-center justify-center w-16 h-16 rounded-full ${resultPVP === 1 ? 'bg-primary/10 text-primary' : 'bg-secondary/10 text-secondary'} mb-4">
                            <i class="fa-solid fa-trophy text-2xl"></i>
                        </div>
                        <h3 class="text-xl font-bold text-gray-900 mb-2">${message}</h3>
                        <p class="text-gray-600 mb-6">本局共进行了 ${stepPVP-1} 步</p>
                        <div class="flex justify-center">
                            <button id="playAgainPVP" class="btn-secondary">
                                <i class="fa-solid fa-play mr-2"></i> 再来一局
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(notification);

            document.getElementById('playAgainPVP').addEventListener('click', () => {
                notification.classList.add('opacity-0');
                setTimeout(() => {
                    document.body.removeChild(notification);
                    restartGamePVP();
                }, 300);
            });
        }

        // 重新开始玩家对战游戏
        function restartGamePVP() {
            resultPVP = -1;
            stepPVP = 1;
            currentPlayerPVP = -1;
            boardPVP = Array.from({ length: sPVP }, () => Array(sPVP).fill(-1));

            // 清除棋盘
            for (let i = 0; i < sPVP; i++) {
                for (let j = 0; j < sPVP; j++) {
                    const cell = boardElementPVP.rows[i].cells[j];
                    cell.className = 'board-cell';
                }
            }

            updatePlayerLabelPVP();
        }

        // 为重新开始按钮绑定事件
        restartButtonPVP.addEventListener('click', restartGamePVP);

        // 初始化游戏
        restartGamePVE();
        restartGamePVP();
    </script>
</body>
</html>
