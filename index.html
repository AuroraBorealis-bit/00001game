<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>金角银边-井字棋游戏（玩家 vs 程序）</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }

        table {
            border-collapse: collapse;
        }

        td {
            width: 100px;
            height: 100px;
            border: 1px solid black;
            text-align: center;
            font-size: 36px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <h1>金角银边-井字棋游戏（玩家 vs 程序）</h1>
    <p id="playerLabel">当前玩家：X</p>
    <table id="board"></table>
    <p>规则：在行、列或对角线上连成三个的玩家将赢得游戏。注意：在第 12 步之前不要输入中心区域（核心 4 个位置）！</p>

    <script>
        // 棋盘大小
        const s = 4;
        // 初始化棋盘，-1 表示空白
        let board = Array.from({ length: s }, () => Array(s).fill(-1));
        // 游戏结果，-1 表示未分出胜负，0 表示 O 获胜，1 表示 X 获胜
        let result = -1;
        // 步数
        let step = 1;
        // 棋盘元素
        const boardElement = document.getElementById('board');

        // 创建棋盘
        for (let i = 0; i < s; i++) {
            const row = document.createElement('tr');
            for (let j = 0; j < s; j++) {
                const cell = document.createElement('td');
                cell.addEventListener('click', () => handlePlayerClick(i, j));
                row.appendChild(cell);
            }
            boardElement.appendChild(row);
        }

        // 检查是否有玩家获胜的函数
        function checkWinner() {
            // 检查行
            for (let i = 0; i < s; i++) {
                let numberX = 0;
                let numberO = 0;
                if (board[i][1]!== board[i][2]) continue;
                for (let j = 0; j < s; j++) {
                    if (board[i][j] === 1) numberX++;
                    else if (board[i][j] === 0) numberO++;
                    else continue;
                    if (numberX === 3 || numberO === 3) {
                        result = numberX === 3? 1 : 0;
                        return;
                    }
                }
            }

            // 检查列
            for (let j = 0; j < s; j++) {
                let numberX = 0;
                let numberO = 0;
                if (board[1][j]!== board[2][j]) continue;
                for (let i = 0; i < s; i++) {
                    if (board[i][j] === 1) numberX++;
                    else if (board[i][j] === 0) numberO++;
                    else continue;
                    if (numberX === 3 || numberO === 3) {
                        result = numberX === 3? 1 : 0;
                        return;
                    }
                }
            }

            // 检查对角线
            function checkAndSet(r1, c1, r2, c2, r3, c3) {
                if (result === -1 && board[r1][c1] === board[r2][c2] && board[r2][c2] === board[r3][c3]) {
                    result = board[r2][c2];
                }
            }

            checkAndSet(0, 0, 1, 1, 2, 2); // 左上到右下
            checkAndSet(1, 1, 2, 2, 3, 3); // 左上到右下
            checkAndSet(0, 3, 1, 2, 2, 1); // 右上到左下
            checkAndSet(3, 0, 2, 1, 1, 2); // 右上到左下
            checkAndSet(0, 1, 1, 2, 2, 3); // 右上
            checkAndSet(1, 0, 2, 1, 3, 2); // 左下
            checkAndSet(0, 2, 1, 1, 2, 0); // 左上
            checkAndSet(1, 3, 2, 2, 3, 1); // 右下
        }

        // 处理玩家点击事件
        function handlePlayerClick(row, col) {
            if (result!== -1) {
                alert("游戏已结束，请重新开始。");
                return;
            }
            if (board[row][col]!== -1) {
                alert("该位置已被占用，请选择其他位置。");
                return;
            }
            if (1 <= row && row < 3 && 1 <= col && col < 3 && step < 12) {
                alert("请在第 12 步之前选择边缘位置。");
                return;
            }
            board[row][col] = 1;
            boardElement.rows[row].cells[col].textContent = 'X';
            step++;
            document.getElementById('playerLabel').textContent = '当前玩家：O';
            if (step > 4) {
                checkWinner();
                if (result === 1) {
                    showEndMessage("恭喜！你赢得了游戏！");
                } else if (step < s * s) {
                    setTimeout(handleAIInput, 500);
                } else if (step === s * s) {
                    showEndMessage("平局，没有人获胜。");
                }
            } else {
                setTimeout(handleAIInput, 500);
            }
        }

        // 简单的 AI 算法，优先检查能获胜的位置，其次检查阻止玩家获胜的位置，再检测特殊情况，最后随机选择
        function handleAIInput() {
            let winRow = -1, winCol = -1;
            let blockRow = -1, blockCol = -1;
            let specialRow = -1, specialCol = -1;
            let availableMoves = [];

            // 检查是否有能让 AI 获胜的位置
            for (let i = 0; i < s; i++) {
                for (let j = 0; j < s; j++) {
                    if (board[i][j] === -1) {
                        if (1 <= i && i < 3 && 1 <= j && j < 3 && step < 12) continue;
                        board[i][j] = 0;
                        checkWinner();
                        if (result === 0) {
                            winRow = i;
                            winCol = j;
                        }
                        result = -1;
                        board[i][j] = -1;
                    }
                }
            }

            if (winRow!== -1) {
                board[winRow][winCol] = 0;
                boardElement.rows[winRow].cells[winCol].textContent = 'O';
                step++;
                document.getElementById('playerLabel').textContent = '当前玩家：X';
                checkWinner();
                if (result === 0) {
                    showEndMessage("很遗憾，你输了。");
                }
                return;
            }

            // 检查是否有需要阻止玩家获胜的位置
            for (let i = 0; i < s; i++) {
                for (let j = 0; j < s; j++) {
                    if (board[i][j] === -1) {
                        if (1 <= i && i < 3 && 1 <= j && j < 3 && step < 12) continue;
                        board[i][j] = 1;
                        checkWinner();
                        if (result === 1) {
                            blockRow = i;
                            blockCol = j;
                        }
                        result = -1;
                        board[i][j] = -1;
                    }
                }
            }

            if (blockRow!== -1) {
                board[blockRow][blockCol] = 0;
                boardElement.rows[blockRow].cells[blockCol].textContent = 'O';
                step++;
                document.getElementById('playerLabel').textContent = '当前玩家：X';
                if (step > 4) {
                    checkWinner();
                    if (result === 0) {
                        showEndMessage("很遗憾，你输了。");
                    } else if (step === s * s) {
                        showEndMessage("平局，没有人获胜。");
                    }
                }
                return;
            }

            // 在前六步中检测特殊情况
            if (step <= 12) {
                // 检查行
                for (let i = 0; i < s; i++) {
                    let hasXInMiddle = (board[i][1] === 1 || board[i][2] === 1);
                    let allOthersEmpty = true;
                    for (let j = 0; j < s; j++) {
                        if (j!== 1 && j!== 2 && board[i][j]!== -1) {
                            allOthersEmpty = false;
                            break;
                        }
                    }
                    if (hasXInMiddle && allOthersEmpty) {
                        for (let j = 0; j < s; j++) {
                            if (board[i][j] === -1) {
                                if (1 <= i && i < 3 && 1 <= j && j < 3 && step < 12) continue;
                                specialRow = i;
                                specialCol = j;
                                break;
                            }
                        }
                        if (specialRow!== -1) break;
                    }
                }

                // 若行中未找到，检查列
                if (specialRow === -1) {
                    for (let j = 0; j < s; j++) {
                        let hasXInMiddle = (board[1][j] === 1 || board[2][j] === 1);
                        let allOthersEmpty = true;
                        for (let i = 0; i < s; i++) {
                            if (i!== 1 && i!== 2 && board[i][j]!== -1) {
                                allOthersEmpty = false;
                                break;
                            }
                        }
                        if (hasXInMiddle && allOthersEmpty) {
                            for (let i = 0; i < s; i++) {
                                if (board[i][j] === -1) {
                                    if (1 <= i && i < 3 && 1 <= j && j < 3 && step < 12) continue;
                                    specialRow = i;
                                    specialCol = j;
                                    break;
                                }
                            }
                            if (specialRow!== -1) break;
                        }
                    }
                }
            }

            if (specialRow!== -1) {
                board[specialRow][specialCol] = 0;
                boardElement.rows[specialRow].cells[specialCol].textContent = 'O';
                step++;
                document.getElementById('playerLabel').textContent = '当前玩家：X';
                if (step > 4) {
                    checkWinner();
                    if (result === 0) {
                        showEndMessage("很遗憾，你输了。");
                    } else if (step === s * s) {
                        showEndMessage("平局，没有人获胜。");
                    }
                }
                return;
            }

            // 收集所有可用的位置
            for (let i = 0; i < s; i++) {
                for (let j = 0; j < s; j++) {
                    if (board[i][j] === -1) {
                        if (1 <= i && i < 3 && 1 <= j && j < 3 && step < 12) continue;
                        availableMoves.push([i, j]);
                    }
                }
            }

            if (availableMoves.length > 0) {
                let randomIndex = Math.floor(Math.random() * availableMoves.length);
                let [row, col] = availableMoves[randomIndex];
                board[row][col] = 0;
                boardElement.rows[row].cells[col].textContent = 'O';
                step++;
                document.getElementById('playerLabel').textContent = '当前玩家：X';
                if (step > 4) {
                    checkWinner();
                    if (result === 0) {
                        showEndMessage("很遗憾，你输了。");
                    } else if (step === s * s) {
                        showEndMessage("平局，没有人获胜。");
                    }
                }
            }
        }

        // 显示游戏结束信息，并提供再来一局的选项
        function showEndMessage(message) {
            const choice = confirm(message + "\n是否再来一局？");
            if (choice) {
                // 重置游戏状态
                result = -1;
                step = 1;
                board = Array.from({ length: s }, () => Array(s).fill(-1));
                // 重置棋盘按钮的文本
                for (let i = 0; i < s; i++) {
                    for (let j = 0; j < s; j++) {
                        boardElement.rows[i].cells[j].textContent = '';
                    }
                }
                document.getElementById('playerLabel').textContent = '当前玩家：X';
            } else {
                window.close();
            }
        }
    </script>
</body>

</html>
